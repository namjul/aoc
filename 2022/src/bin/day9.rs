use std::collections::HashSet;

// == Initial State ==
//
// ......
// ......
// ......
// ......
// H.....  (H covers T, s)
//
// == R 4 ==
//
// ......
// ......
// ......
// ......
// TH....  (T covers s)
//
// ......
// ......
// ......
// ......
// sTH...
//
// ......
// ......
// ......
// ......
// s.TH..
//
// ......
// ......
// ......
// ......
// s..TH.
//
// == U 4 ==
//
// ......
// ......
// ......
// ....H.
// s..T..
//
// ......
// ......
// ....H.
// ....T.
// s..t..
//
// ......
// ....H.
// ....T.
// ......
// s.....
//
// ....H.
// ....T.
// ......
// ......
// s.....
//
// == L 3 ==
//
// ...H..
// ....T.
// ......
// ......
// s.....
//
// ..HT..
// ......
// ......
// ......
// s.....
//
// .HT...
// ......
// ......
// ......
// s.....
//
// == D 1 ==
//
// ..T...
// .H....
// ......
// ......
// s.....
//
// == R 4 ==
//
// ..T...
// ..H...
// ......
// ......
// s.....
//
// ..T...
// ...H..
// ......
// ......
// s.....
//
// ......
// ...TH.
// ......
// ......
// s.....
//
// ......
// ....TH
// ......
// ......
// s.....
//
// == D 1 ==
//
// ......
// ....T.
// .....H
// ......
// s.....
//
// == L 5 ==
//
// ......
// ....T.
// ....H.
// ......
// s.....
//
// ......
// ....T.
// ...H..
// ......
// s.....
//
// ......
// ......
// ..HT..
// ......
// s.....
//
// ......
// ......
// .HT...
// ......
// s.....
//
// ......
// ......
// HT....
// ......
// s.....
//
// == R 2 ==
//
// ......
// ......
// .H....  (H covers T)
// ......
// s.....
//
// ......
// ......
// .TH...
// ......
// s.....
//
// ..##..
// ...##.
// .###o.
// ....#.
// s###..

#[derive(Debug, Clone, PartialEq)]
struct Position(isize, isize);

fn calc_tail_position(tail: &mut Position, head: &mut Position) -> (isize, isize) {
    if tail == head {
        return (tail.0, tail.1);
    }

    // move tail on the x-axis
    let x_offset = head.0 - tail.0;
    if x_offset < -1 || x_offset > 1 {
        if x_offset > 0 {
            tail.0 += 1;
        } else {
            tail.0 -= 1;
        }
        if head.1 != tail.1 {
            tail.1 = head.1;
        }
    }

    // move tail on the y-axis
    let y_offset = head.1 - tail.1;
    if y_offset < -1 || y_offset > 1 {
        if y_offset > 0 {
            tail.1 += 1;
        } else {
            tail.1 -= 1;
        }

        if head.0 != tail.0 {
            tail.0 = head.0;
        }
    }

    println!("new tail position: {:#?}", tail);

    return (tail.0, tail.1);
}

fn main() -> std::io::Result<()> {
    let mut tail_positions: HashSet<(isize, isize)> = HashSet::new();

    tail_positions.insert((0, 0));

    // (x,y)
    let mut head = Position(0, 0);
    let mut tail = Position(0, 0);

    let input = std::fs::read_to_string("./src/bin/day9.prod.txt")?;

    for line in input.lines() {
        let (direction, steps) = line
            .split_once(" ")
            .map(|(direction, steps)| return (direction, steps.parse::<isize>().unwrap()))
            .unwrap();

        for step in 1..steps + 1 {
            match direction {
                "R" => {
                    println!("Right: {}", step);
                    // move head
                    head.0 += 1;
                    // move tail
                    tail_positions.insert(calc_tail_position(&mut tail, &mut head));
                }
                "L" => {
                    println!("Left: {}", step);
                    head.0 -= 1;
                    // move tail
                    tail_positions.insert(calc_tail_position(&mut tail, &mut head));
                }
                "U" => {
                    println!("Up: {}", step);
                    head.1 += 1;
                    // move tail
                    tail_positions.insert(calc_tail_position(&mut tail, &mut head));
                }
                "D" => {
                    println!("Down: {}", step);
                    head.1 -= 1;
                    // move tail
                    tail_positions.insert(calc_tail_position(&mut tail, &mut head));
                }
                _ => panic!("Wrong direction"),
            }
        }

        // print!("tail: {:#?}\n head: {:#?}", tail, head);
        print!("\n=====\n");
    }
    println!("tail: {:#?}, head: {:#?}", tail, head);
    println!("{:#?}", tail_positions);
    println!("{}", tail_positions.len());

    return Ok(());
}
